* Config
** Native compilation
#+begin_src elisp
(setq native-comp-async-report-warnings-errors 'silent)
#+end_src

** Scrolling
#+begin_src elisp
(defun jt/scroll-up-command ()
  "Scroll up, silently stopping at end of buffer."
  (interactive)
  (condition-case nil
      (scroll-up-command)
    (end-of-buffer nil)))

(defun jt/scroll-down-command ()
  "Scroll down, silently stopping at beginning of buffer."
  (interactive)
  (condition-case nil
      (scroll-down-command)
    (beginning-of-buffer nil)))

(global-set-key [next] #'jt/scroll-up-command)
(global-set-key [prior] #'jt/scroll-down-command)
#+end_src

** GUI customisation
#+begin_src elisp
;;TODO setxkbmap -option 'ctrl:nocaps'
;; TODO review cider and lsp config https://github.com/andreyorst/dotfiles/blob/master/.config/emacs/init.el
;; Disable GUI menu bars
(menu-bar-mode -1)
(tool-bar-mode -1)
(savehist-mode 1)
(add-to-list 'savehist-additional-variables 'kill-ring)
(recentf-mode 1) ; via M-x ffap
(setq recentf-max-saved-items 200)

(setq confirm-kill-processes nil)
(global-unset-key (kbd "C-x C-c")) ; stop accidently quitting Emacs while I'm learning!

(add-to-list 'default-frame-alist '(font . "Source Code Pro 15"))

;; Maximize new frames when on laptop screen only
(defun jt/on-laptop-screen-p ()
  "Return non-nil if currently on the laptop's built-in screen."
  (let ((monitors (display-monitor-attributes-list)))
    (and (= (length monitors) 1)
         (string-prefix-p "eDP" (alist-get 'name (car monitors))))))

(defun jt/maybe-maximize-frame (frame)
  "Maximize FRAME if on laptop screen."
  (when (jt/on-laptop-screen-p)
    (set-frame-parameter frame 'fullscreen 'maximized)))
(add-hook 'after-make-frame-functions #'jt/maybe-maximize-frame)

;; Enable vertical scroll bar
(add-to-list 'default-frame-alist '(vertical-scroll-bars . right))
(add-to-list 'default-frame-alist '(horizontal-scroll-bars . nil))

(add-to-list 'load-path "~/.emacs.d/site-lisp")

;; Smooth scrolling (mimics GTK scrollbar drag)
(setq mwheel-coalesce-scroll-events nil)
(require 'scrollbar-scroll)
(scrollbar-scroll-mode 1)

;; Touchscreen gesture support
(require 'touch-handler)

;; Hide line wrap continuation arrows in fringe
(setf (cdr (assq 'continuation fringe-indicator-alist)) '(nil nil))

;; Disable GTK scroll bars (using touch/gesture scrolling)
(scroll-bar-mode -1)

;; Disable splash screen and startup message
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)

(add-hook 'org-mode-hook
      (lambda ()
	(setq truncate-lines nil)
        (setq word-wrap t)))
#+end_src

** Display time configuration
#+begin_src elisp
;; Show the time in the modeline
(setq display-time-24hr-format t)
(setq display-time-default-load-average nil)
(setq display-time-day-and-date t)
(setq display-time-interval 1)
(display-time-mode)
#+end_src

** Backup file configuration
#+begin_src elisp
;; Save backup files in /tmp
(setq backup-directory-alist
	`((".*" . ,"~/emacs-tmp/")))
(setq auto-save-file-name-transforms
      `((".*" ,"~/emacs-tmp/" t)))
#+end_src

** Server mode
#+begin_src elisp
(require 'server)
(unless (server-running-p)
  (server-start))
#+end_src

** Inherit environment from shell
#+begin_src elisp
;; Inherit environment from default shell
(use-package exec-path-from-shell
  :ensure t
  :config
  (exec-path-from-shell-initialize)
  (exec-path-from-shell-copy-envs (list "GOROOT" "GOPATH")))
#+end_src

** writeroom
#+begin_src elisp
;; @jt-menu View | w | Writeroom mode | writeroom-mode
;; distraction free editing - central column, minimal
(use-package writeroom-mode
  :ensure t
  :config
  (add-hook 'writeroom-mode-enable-hook (lambda () (company-mode -1)))
  (add-hook 'writeroom-mode-disable-hook (lambda () (company-mode 1))))
#+end_src

** theme-changer
#+begin_src elisp
    (setq calendar-location-name "London, United Kingdom")
    (setq calendar-latitude 51.48)
    (setq calendar-longitude 0.00)
    (use-package theme-changer
      :ensure t)
    (change-theme 'spacemacs-light 'spacemacs-dark)
    (when (daemonp)
      (add-hook 'server-after-make-frame-hook
                (lambda ()
                  (change-theme 'spacemacs-light 'spacemacs-dark))))
#+end_src

** trailing whitespace
#+begin_src elisp
(setq-default show-trailing-whitespace t)
#+end_src

** Ivy
I install Ivy, because I like the buffer switcher and the file finder. The buffer switcher is compatible with Perspective, and the file finder is nice. I install the ~counsel~ package, but don't enable ~ivy-mode~.
#+begin_src elisp
  ;; Ivy
  (use-package counsel :ensure t)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) ")
  (global-set-key (kbd "C-x b") 'persp-ivy-switch-buffer)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file)
#+end_src

** Vertico and friends
I use Vertico, and its related packages, for most completion. Ivy is used just for buffer switching, and opening files.
*** Vertico
Vertico provides vertical narrowing and completion, but is pretty basic compared to Ivy.
#+begin_src elisp
  (use-package vertico :ensure t :init (vertico-mode))
  (global-set-key (kbd "M-x") 'execute-extended-command) ; not really necessary, but included to explicitly unset any other keybindings.
  ;; note, can't eval above command directly?
#+end_src
*** Marginalia
Marginalia adds useful metadata to items in Vertico's completion results, e.g. descriptions of commands in ~M-x~.
#+begin_src elisp
(use-package marginalia :ensure t :init (marginalia-mode))
#+end_src
*** Consult
Consult offers a wide range of searching commands. I just use it as a replacement for swiper, because it feels faster.
#+begin_src elisp :results none
(use-package consult :ensure t)
(global-set-key (kbd "C-s") 'consult-line)
(global-set-key (kbd "C-x C-c") 'consult-buffer)
#+end_src
*** Orderless
Orderless provides a completion style for Vertico that allows matches to be narrowed using space separated terms, much like Ivy does out of the box
#+begin_src elisp
(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src
However, I disable orderless for Company, because I find it affects performance whilst editing buffers. The function below is taken from [[https://github.com/oantolin/orderless#company][here]].
#+begin_src elisp
;; We follow a suggestion by company maintainer u/hvis:
;; https://www.reddit.com/r/emacs/comments/nichkl/comment/gz1jr3s/
(defun company-completion-styles (capf-fn &rest args)
  (let ((completion-styles '(basic partial-completion)))
    (apply capf-fn args)))
(advice-add 'company-capf :around #'company-completion-styles)
#+end_src
** Avy
#+begin_src elisp :results none
(use-package avy :ensure t)
(global-set-key (kbd "C-f") #'avy-goto-char-timer)
(global-set-key (kbd "M-g g") #'avy-goto-line)
#+end_src
** Spaceline modeline
*** Install spaceline
#+begin_src elisp :results none
(use-package spaceline
  :ensure t
  :config
  (require 'spaceline-config)
  (spaceline-spacemacs-theme))
#+end_src
** Display line numbers
#+begin_src elisp :results none
(setq display-line-numbers-type t)
(global-display-line-numbers-mode)
#+end_src
** Line highlighting
#+begin_src elisp
;; Highlight current line
(global-hl-line-mode)
#+end_src
** Perspective workspaces
#+begin_src elisp
;; Perspective
(use-package perspective
  :ensure t
  :custom
  (setq persp-sort 'access)
  (persp-mode-prefix-key (kbd "C-x x"))
  :init
  (persp-mode))

;; @jt-menu Perspective | p a | Add buffer
(defun persp-add-and-switch-buffer (buffer-or-name)
  (interactive
   (list
    (let ((read-buffer-function nil))
      (read-buffer "Add buffer to perspective: "))))
  (persp-add-buffer buffer-or-name)
  (switch-to-buffer buffer-or-name))

;; @jt-menu Perspective | p s | Switch & add buffer
(defun persp-switch-and-add-buffer ()
  (interactive)
  (let ((buffer (buffer-name)))
    (persp-switch ())
    (persp-add-and-switch-buffer buffer)))

;; Key bindings for replacement buffer switch, and buffer moving commands
(define-key perspective-map (kbd "a") 'persp-add-and-switch-buffer)
(define-key perspective-map (kbd "S") 'persp-switch-and-add-buffer)
#+end_src
*** Switch to workspace for a projectile project
#+begin_src elisp
;; @jt-menu Perspective | p p | Switch project
(defun jt/persp-project-switch ()
  (interactive)
  (persp-switch "persp-project-switch")
  (projectile-switch-project)
  (persp-rename (projectile-project-name)))

(define-key perspective-map (kbd "P") #'jt/persp-project-switch)
#+end_src
*** Rename current perspective to current project name
#+begin_src elisp :results none
;; @jt-menu Perspective | p r | Rename to project
;; @jt-menu Perspective | p n | Next | persp-next
;; @jt-menu Perspective | p b | Switch | persp-switch
(defun jt/rename-perspective-to-current-project ()
  (interactive)
  (persp-rename (projectile-project-name)))
(define-key perspective-map (kbd "R") #'jt/rename-perspective-to-current-project)
#+end_src
** Window switcher
#+begin_src elisp
;; Numbered window switcher
(use-package winum :ensure t)
(winum-mode 1)
#+end_src
*** Perspective segment
#+begin_src elisp :results none
(setq perspective-segment (make-symbol "perspective-segment"))
(spaceline-define-segment perspective-segment
  "Displays the current perspective"
  (persp-current-name))
#+end_src
*** Time segments
#+begin_src elisp :results none
(setq time-segment (make-symbol "time-segment"))
(spaceline-define-segment time-segment
  "Displays the current time"
  (format-time-string "%a %b %e %H:%M:%S"))
(setq utc-segment (make-symbol "utc-segment"))
(spaceline-define-segment utc-segment
  "Displays the current utc"
  (format-time-string "%H:%M UTC" nil t))
#+end_src
*** Configure modeline
#+begin_src elisp :results none
(// spaceline-toggle-window-number-off)                                      ; otherwise the evil state indicator isn't shown
(// setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state) ; colorise the modeline based on the evil state
(setq powerline-default-separator "arrow")
(setq spaceline-separator-dir-left '(left . left))
(setq spaceline-separator-dir-right '(right . right))
(spaceline-define-segment my-string "FOCUS!" "FOCUS!    ")



(spaceline-compile
  ; left side
  '(
    window-number
    ((buffer-modified buffer-id) :priority 98)
    (major-mode :priority 79)
    (process :when active)
    (version-control :when active)
    ((flycheck-error flycheck-warning flycheck-info) :when active :priority 89)
   )
  ; right side
  '(
    (battery)
    (time-segment)
    ;;(utc-segment)
    ;;(perspective-segment) ;; disabling it until I'm more comfortable
    (buffer-position)
    (my-string)

   )
  )
#+end_src
** Battery indicator
#+begin_src elisp
;; Fancy battery indicator
(use-package fancy-battery :ensure t)
(add-hook 'after-init-hook #'fancy-battery-mode)
(setq fancy-battery-show-percentage t)
(defun spaceline--fancy-battery-mode-line ()
  "Assemble a mode line string for Fancy Battery Mode."
  (when fancy-battery-last-status
    (let* ((type (cdr (assq ?L fancy-battery-last-status)))
           (percentage (spaceline--fancy-battery-percentage))
           (time (spaceline--fancy-battery-time)))
      (cond
       ((string= "on-line" type) (concat " ∞" percentage))
       ((string= type "") " No Battery")
       (t (concat (if (string= "AC" type) " AC" "") percentage time))))))
#+end_src
** Magit
#+begin_src elisp
;; @jt-menu Git | g s | Magit status | magit-status
;; @jt-menu Git | g l | Magit log | magit-log-current
;; @jt-menu Git | g b | Magit blame | magit-blame
(use-package magit :ensure t)
(setq magit-diff-refine-hunk (quote all)) ; Use word diffs when showing diffs
#+end_src
** Auto completion with company mode
#+begin_src elisp
;; Auto-completion
(use-package company :ensure t)
(add-hook 'after-init-hook #'global-company-mode) ; Enable company mode in all buffers
#+end_src
** Flyspell in text mode
#+begin_src elisp :results none
(defun jt/text-mode-hook ()
  (flyspell-mode))
(add-hook 'text-mode-hook #'jt/text-mode-hook)
#+end_src

** Org mode customisation
*** Org config and key bindings
#+begin_src elisp :results none
;; @jt-menu Org | o s | Insert src block | org-insert-structure-template
;; @jt-menu Org | o t | Cycle TODO | org-todo
;; @jt-menu Org | o c | Capture | org-capture
;; @jt-menu Org | o a | Agenda | org-agenda
;; @jt-menu Org | o l | Insert link | org-insert-link
;; @jt-menu Org | o e | Export | org-export-dispatch
;; @jt-menu Org | o p | Set property | org-set-property
;; @jt-menu Org | o . | Set timestamp | org-time-stamp
;; @jt-menu Org | o ? | Speed keys help | org-speed-command-help
;; Org mode customisation
(setq org-agenda-files '("~/org/"))

;; Hourly backups of org files with pruning
(defun jt/backup-org-files ()
  "Copy org files to .backups with timestamp, then prune old backups."
  (let* ((backup-dir (expand-file-name ".backups" "~/org"))
         (timestamp (format-time-string "%Y%m%d-%H%M"))
         (dest-dir (expand-file-name timestamp backup-dir)))
    (make-directory backup-dir t)
    (make-directory dest-dir t)
    (dolist (file (directory-files "~/org" t "\\.org$"))
      (unless (string-prefix-p ".#" (file-name-nondirectory file))
        (copy-file file (expand-file-name (file-name-nondirectory file) dest-dir) t)))
    (jt/prune-org-backups backup-dir)))

(defun jt/prune-org-backups (backup-dir)
  "Keep one backup per bucket: 0-1h, 1h-1d, 1d-1w, 1w-1m, 1m-1y, 1y+."
  (let* ((now (float-time))
         (hour 3600) (day 86400) (week 604800) (month 2592000) (year 31536000)
         (buckets (list 0 hour day week month year most-positive-fixnum))
         (dirs (seq-filter
                #'file-directory-p
                (directory-files backup-dir t "^[0-9]\\{8\\}-[0-9]\\{4\\}$")))
         (aged (mapcar
                (lambda (d)
                  (cons d (- now (float-time (nth 5 (file-attributes d))))))
                dirs))
         (keep nil))
    (dotimes (i (1- (length buckets)))
      (let* ((min-age (nth i buckets))
             (max-age (nth (1+ i) buckets))
             (in-bucket (seq-filter
                         (lambda (x) (and (>= (cdr x) min-age) (< (cdr x) max-age)))
                         aged)))
        (when in-bucket
          (if (= i 0)
              (push (caar (seq-sort-by #'cdr #'< in-bucket)) keep)
            (push (caar (seq-sort-by #'cdr #'> in-bucket)) keep)))))
    (dolist (entry aged)
      (unless (member (car entry) keep)
        (delete-directory (car entry) t)))))

(defvar jt/backup-timer nil)
(when jt/backup-timer (cancel-timer jt/backup-timer))
(setq jt/backup-timer (run-at-time "1 hour" 3600 #'jt/backup-org-files))
(setq org-capture-templates
      '(("w" "Work")
        ("wt" "Work TODO" entry (file+headline "~/org/work.org" "Unsorted")
         "** TODO %?\n%u\n%^{Schedule?||SCHEDULED: %^t}")
        ("wd" "Work Deadline" entry (file+headline "~/org/work.org" "Unsorted")
         (file "~/org/templates/work-deadline.org"))
        ("wn" "Work Next Task" entry (file+headline "~/org/work.org" "Unsorted")
         "** NEXT %?\nSCHEDULED: %t")
        ("h" "Home")
        ("ht" "Home TODO" entry (file+headline "~/org/home.org" "Unsorted")
         (file "~/org/templates/todo.org"))
        ("f" "Fun")
        ("ft" "Fun TODO" entry (file+headline "~/org/fun.org" "Unsorted")
         (file "~/org/templates/todo.org"))))
(// setq org-startup-folded t) ; open org files folded, rather than expanded
(setq org-edit-src-content-indentation 0) ; do not indent code in source blocks
(setq org-startup-with-inline-images nil) ; use svg sidebar instead
(setq org-adapt-indentation nil) ; do not indent headline contents with headline
(setq org-use-speed-commands t) ; use speed keys in org buffers
(define-key org-mode-map (kbd "C-c C-s") #'org-insert-structure-template)
(define-key org-mode-map (kbd "C-c o c") #'org-capture)
(require 'org-agenda)
(define-key org-agenda-mode-map (kbd "C-c o c") #'org-capture)
(define-key org-mode-map (kbd "C-c o a") #'org-agenda)

(setq org-agenda-time-grid
      '((daily today)
        (800 1000 1200 1400 1600 1800 2000)
        "......" "----------------"))

;; GTD-style agenda view from https://www.labri.fr/perso/nrougier/GTD/index.html
(setq org-agenda-custom-commands
      '(("g" "Get Things Done (GTD)"
         ((agenda ""
                  ((org-agenda-span 'day)
                   (org-agenda-skip-function
                    '(org-agenda-skip-entry-if 'deadline))
                   (org-deadline-warning-days 0)))
          (tags-todo "+DEADLINE>=\"<-7d>\"+DEADLINE<=\"<+7d>\"/NEXT"
                ((org-agenda-prefix-format "  %-12:c")
                 (org-agenda-sorting-strategy '(deadline-up))
                 (org-agenda-overriding-header "\nDeadlines\n")))
          (todo "NEXT"
                ((org-agenda-skip-function
                  '(org-agenda-skip-entry-if 'deadline))
                 (org-agenda-prefix-format "  %i %-12:c ")
                 (org-agenda-overriding-header "\nTasks\n")))))))

(setq org-agenda-block-separator nil)

(defun jt/deadline-days-prefix ()
  "Return string showing days until deadline for current entry."
  (let ((deadline (org-get-deadline-time (point))))
    (if deadline
        (let ((days (- (time-to-days deadline) (time-to-days (current-time)))))
          (cond
           ((< days 0) (format "%dd ago" (- days)))
           ((= days 0) "today")
           ((= days 1) "tomorrow")
           (t (format "in %dd" days))))
      "")))

(defun jt/org-agenda-finalize-hook ()
  "Clean up agenda view after it's built."
  (jt/agenda-add-deadline-days)
  (jt/agenda-add-scheduled-dates)
  (jt/agenda-hide-empty-sections)
  (jt/agenda-collapse-empty-lines))
(add-hook 'org-agenda-finalize-hook #'jt/org-agenda-finalize-hook)

(defun jt/agenda-hide-empty-sections ()
  "Hide section headers that have no entries."
  (let ((inhibit-read-only t))
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "^Deadlines$" nil t)
        (let ((header-start (line-beginning-position)))
          (forward-line 1)
          (if (or (eobp) (looking-at "^[A-Z]") (looking-at "^$"))
              (delete-region header-start (point))))))))

(defun jt/agenda-add-deadline-days ()
  "Add days-until-deadline prefix to deadline entries in agenda."
  (let ((inhibit-read-only t))
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "^Deadlines$" nil t)
        (forward-line 1)
        (while (and (not (eobp))
                    (not (looking-at "^[A-Z]")))
          (when (looking-at "^  ")
            (let* ((marker (org-get-at-bol 'org-hd-marker))
                   (days-str (when marker
                               (with-current-buffer (marker-buffer marker)
                                 (goto-char marker)
                                 (jt/deadline-days-prefix)))))
              (when (and days-str (not (string-empty-p days-str)))
                (goto-char (+ (line-beginning-position) 2))
                (insert (format "%-10s" days-str)))))
          (forward-line 1))))))

(defun jt/agenda-add-scheduled-dates ()
  "Add scheduled date suffix to entries in Tasks section."
  (let ((inhibit-read-only t))
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "^Tasks$" nil t)
        (forward-line 1)
        (while (and (not (eobp))
                    (not (looking-at "^[A-Z]")))
          (when (looking-at "^  ")
            (let* ((marker (org-get-at-bol 'org-hd-marker)))
              (when marker
                (let ((scheduled (with-current-buffer (marker-buffer marker)
                                   (goto-char marker)
                                   (org-get-scheduled-time (point)))))
                  (when scheduled
                    (end-of-line)
                    (insert (propertize (format " [%s]" (format-time-string "%b %d" scheduled))
                                        'face 'org-date)))))))
          (forward-line 1))))))

(defun jt/org-agenda-add-header ()
  "Add keybinding hints to org-agenda header."
  (setq header-line-format
        "  n/p: next/prev  t: TODO  RET: goto  f/b: fwd/back  .: today  r: refresh  d: pushback  S: save  C: clear  h/w/F: org files  q: quit")
  (setq-local show-trailing-whitespace nil))
(add-hook 'org-agenda-mode-hook #'jt/org-agenda-add-header)

(setq org-agenda-sticky nil)

(defvar jt/org-agenda-day-offset 0
  "Current day offset for agenda navigation.")

(defun jt/org-agenda-forward ()
  "Move agenda forward by one day, works from anywhere in the buffer."
  (interactive)
  (setq jt/org-agenda-day-offset (1+ jt/org-agenda-day-offset))
  (let ((org-agenda-start-day (format "+%dd" jt/org-agenda-day-offset)))
    (org-agenda nil "g")))

(defun jt/org-agenda-backward ()
  "Move agenda backward by one day, works from anywhere in the buffer."
  (interactive)
  (setq jt/org-agenda-day-offset (1- jt/org-agenda-day-offset))
  (let ((org-agenda-start-day (format "%+dd" jt/org-agenda-day-offset)))
    (org-agenda nil "g")))

(defun jt/org-agenda-today ()
  "Jump to today in agenda, works from anywhere in the buffer."
  (interactive)
  (setq jt/org-agenda-day-offset 0)
  (org-agenda nil "g"))

(with-eval-after-load 'org-agenda
  (define-key org-agenda-mode-map (kbd "f") #'jt/org-agenda-forward)
  (define-key org-agenda-mode-map (kbd "b") #'jt/org-agenda-backward)
  (define-key org-agenda-mode-map (kbd ".") #'jt/org-agenda-today)
  (define-key org-agenda-mode-map (kbd "h") (lambda () (interactive) (find-file "~/org/home.org")))
  (define-key org-agenda-mode-map (kbd "w") (lambda () (interactive) (find-file "~/org/work.org")))
  (define-key org-agenda-mode-map (kbd "F") (lambda () (interactive) (find-file "~/org/fun.org"))))

(defvar jt/org-agenda-pending-pushbacks nil
  "List of (marker . days) for pending pushbacks.")

(defun jt/org-agenda-pushback-deadline ()
  "Mark item at point to push back by one day. Press S to save all.
Works on any agenda line with a timestamp (deadlines, scheduled, or calendar events)."
  (interactive)
  (let ((marker (org-get-at-bol 'org-marker))
        (hdmarker (org-get-at-bol 'org-hd-marker)))
    (when (or marker hdmarker)
      (push (cons (copy-marker (or marker hdmarker)) 1) jt/org-agenda-pending-pushbacks)
      (let ((inhibit-read-only t))
        (beginning-of-line)
        (cond
         ((re-search-forward "Deadline:" (line-end-position) t)
          (replace-match "Deadline+1:"))
         ((re-search-forward "Scheduled:" (line-end-position) t)
          (replace-match "Scheduled+1:"))
         (t
          (end-of-line)
          (insert " [+1d]"))))))
  (forward-line))

(defun jt/org-agenda-flush ()
  "Apply all pending pushbacks and save."
  (interactive)
  (let ((count (length jt/org-agenda-pending-pushbacks)))
    (dolist (item jt/org-agenda-pending-pushbacks)
      (let ((marker (car item))
            (days (cdr item)))
        (when (marker-buffer marker)
          (with-current-buffer (marker-buffer marker)
            (goto-char marker)
            (cond
             ((org-get-deadline-time (point))
              (org-deadline nil (format "+%dd" days)))
             ((org-get-scheduled-time (point))
              (org-schedule nil (format "+%dd" days)))
             (t
              (org-end-of-meta-data t)
              (when (re-search-backward org-ts-regexp (line-beginning-position -2) t)
                (org-timestamp-change days 'day))))))))
    (org-save-all-org-buffers)
    (setq jt/org-agenda-pending-pushbacks nil)
    (org-agenda-redo)
    (message "Applied %d pushbacks" count)))

(defun jt/org-agenda-clear-pending ()
  "Clear pending pushbacks without applying."
  (interactive)
  (setq jt/org-agenda-pending-pushbacks nil)
  (org-agenda-redo)
  (message "Cleared pending pushbacks"))

(define-key org-agenda-mode-map (kbd "d") #'jt/org-agenda-pushback-deadline)
(define-key org-agenda-mode-map (kbd "S") #'jt/org-agenda-flush)
(define-key org-agenda-mode-map (kbd "C") #'jt/org-agenda-clear-pending)
(setq org-image-actual-width nil) ; allow image widths to be overridden with #+ATTR_ORG: :width 100

(defun jt/capture-update-header ()
  "Add extra hint to capture buffer header line."
  (setq header-line-format
        (concat header-line-format
                "  C-c C-c: finish, C-c C-k: abort, M-x org-capture-mode: convert to normal buffer")))
(add-hook 'org-capture-mode-hook #'jt/capture-update-header)

(defun jt/org-mode-hook ()
  (flyspell-mode))
(add-hook 'org-mode-hook #'jt/org-mode-hook)
#+end_src
*** TODO keywords
Extended TODO keywords following GTD principles. See https://cachestocaches.com/2016/9/my-workflow-org-agenda/
- TODO: tasks/projects that need to get done (a "project" is any TODO with sub-TODOs)
- NEXT: the next action within a project; a project without NEXT is "stuck"
- WAITING: blocked on someone else (prompts for note on who/why)
- INACTIVE: ideas to revisit later when time permits
- DONE: completed
- CANCELLED: fizzled out (prompts for note on why)
- MEETING: meeting notes

Use ~C-c C-t~ then the shortcut key to quickly change state. The ~@~ suffix prompts for a note.
#+begin_src elisp
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "WAITING(w@)" "INACTIVE(i)" "|" "DONE(d)" "CANCELLED(c@)" "MEETING(m)")))

(setq org-todo-keyword-faces
      '(("TODO" . org-warning)
        ("NEXT" . (:foreground "dodger blue" :weight bold))
        ("WAITING" . (:foreground "orange" :weight bold))
        ("INACTIVE" . (:foreground "grey" :weight bold))
        ("CANCELLED" . (:foreground "grey" :strike-through t))
        ("MEETING" . (:foreground "purple"))))

(setq org-log-into-drawer t)
(setq org-log-done 'time)

(defun jt/log-todo-next-creation-date (&rest ignore)
  "Log NEXT creation time in the property drawer under the key 'ACTIVATED'.
From https://www.labri.fr/perso/nrougier/GTD/index.html"
  (when (and (string= (org-get-todo-state) "NEXT")
             (not (org-entry-get nil "ACTIVATED")))
    (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))
(add-hook 'org-after-todo-state-change-hook #'jt/log-todo-next-creation-date)

(setq org-icalendar-store-UID t) ; export tp ical with persistent ids
(add-hook 'org-mode-hook
          (lambda ()
            (dolist (face '(org-document-title
                            org-level-1
                            org-level-2
                            org-level-3))
              (set-face-attribute face nil :height 1.0))))
(setq org-ellipsis "▼")
(use-package org-download :ensure t)
(setq org-download-screenshot-method "spectacle -br -o %s")

;; @jt-menu View | i | Image sidebar | org-image-sidebar-mode
(require 'org-image-sidebar)
(add-hook 'org-mode-hook #'org-image-sidebar-mode)
#+end_src
*** Org babel config
#+begin_src elisp :results none
;; Mermaid babel support
(use-package mermaid-mode :ensure t) ; load mermaid-mode before ob-mermaid, because ob-mermaid has a better babel function
(use-package ob-mermaid :ensure t)

;; Use python3 for python blocks
(setq org-babel-python-command "python3")

;; Org Babel languages
(org-babel-do-load-languages
 'org-babel-load-languages
 '((python . t)
   (mermaid . t)
   (shell . t)
   (emacs-lisp . t)))

(defun jt/org-babel-confirm (lang body)
  (not (or (string= lang "elisp")
	   (string= lang "mermaid")
	   (string= lang "shell")
	   (string= lang "sh")
	   (string= lang "python")
	   (string= lang "bash"))))
(setq org-confirm-babel-evaluate #'jt/org-babel-confirm)
#+end_src

*** Function for copying org links
This function was taken from [[https://emacs.stackexchange.com/questions/3981/how-to-copy-links-out-of-org-mode][StackOverflow]].
#+begin_src elisp
(defun farynaio/org-link-copy (&optional arg)
  "Extract URL from org-mode link and add it to kill ring."
  (interactive "P")
  (let* ((link (org-element-lineage (org-element-context) '(link) t))
          (type (org-element-property :type link))
          (url (org-element-property :path link))
          (url (concat type ":" url)))
    (kill-new url)
    (message (concat "Copied URL: " url))))

(define-key org-mode-map (kbd "C-x C-l") 'farynaio/org-link-copy)
#+end_src
** Which key
#+begin_src elisp
(use-package which-key :ensure t)
(which-key-mode)
#+end_src
** Emoji support
*** Package for inserting emojis
Allows emojis to easily be inserted from a completion menu.
#+begin_src elisp :results none
;; @jt-menu Edit | e | Insert emoji | emojify-insert-emoji
(use-package emojify :ensure t)
(setq emojify-display-style 'unicode)
(setq emojify-emoji-styles '(unicode))
(global-set-key (kbd "C-c i") #'emojify-insert-emoji)
#+end_src
*** Emoji-enabled font
#+begin_src elisp :results none
(when (member "Noto Color Emoji" (font-family-list))
  (set-fontset-font
    t 'symbol (font-spec :family "Noto Color Emoji") nil 'prepend))
#+end_src
** Split and draft function
#+begin_src elisp :results none
;; @jt-menu Edit | d | Draft buffer | jt/split-and-draft-enter
(defun jt/split-and-draft-exit ()
  (interactive)
  (mark-whole-buffer)
  (kill-region nil nil t)
  (kill-buffer-and-window))

(defun jt/split-and-draft-enter ()
  (interactive)
  (split-window)
  (other-window 1)
  (set-window-buffer nil (set-buffer (generate-new-buffer "jt/draft")))
  (markdown-mode)
  (local-set-key (kbd "C-c C-c") #'jt/split-and-draft-exit))

(global-set-key (kbd "C-x D") #'jt/split-and-draft-enter)
#+end_src
** Enable disabled commands
#+begin_src elisp
(put 'narrow-to-region 'disabled nil)
#+end_src
** Info customisation
#+begin_src elisp :results none
(use-package adaptive-wrap :ensure t)
(defun jt/info-mode-hook ()
  (visual-line-mode)
  (adaptive-wrap-prefix-mode)
  (display-line-numbers-mode -1))
(add-hook 'Info-mode-hook #'jt/info-mode-hook)
#+end_src
** PDF tools
#+begin_src elisp :results none
(when (display-graphic-p)
  (use-package pdf-tools :ensure t)
  (pdf-tools-install)
  (defun jt/pdf-view-mode-hook ()
    (display-line-numbers-mode -1)
    (pdf-view-midnight-minor-mode))
  (add-hook 'pdf-view-mode-hook #'jt/pdf-view-mode-hook))
#+end_src
** Custom global keybindings for common commands
#+begin_src elisp :results none
(// global-set-key (kbd "C-x E") #'eww)
;; @jt-menu Edit | y | Yank from kill-ring | yank-from-kill-ring
(global-set-key (kbd "C-x y") #'yank-from-kill-ring)
;; @jt-menu Edit | j | Join line | join-line
(global-set-key (kbd "M-j") #'join-line)
;; @jt-menu View | v | Visual line mode | visual-line-mode
(global-set-key (kbd "C-x V") #'visual-line-mode)
;; @jt-menu View | l | Line numbers | display-line-numbers-mode
;; @jt-menu Tools | t u | Browse URL at point | browse-url-at-point
(global-set-key (kbd "M-q") #'browse-url-at-point)
;; [[https://google.com/][asdf]]
#+end_src
** Org-roam
#+begin_src elisp
;; @jt-menu Org-roam | n f | Find node | org-roam-node-find
;; @jt-menu Org-roam | n i | Insert node | org-roam-node-insert
;; @jt-menu Org-roam | n c | Capture | org-roam-capture
;; @jt-menu Org-roam | n l | Toggle buffer | org-roam-buffer-toggle
;; @jt-menu Org-roam | n j | Today's daily | org-roam-dailies-goto-today
;; @jt-menu Org-roam | n g | Graph | org-roam-graph
(use-package org-roam
  :ensure t
  :custom
  (org-roam-directory (file-truename "~/org-roam/"))
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n g" . org-roam-graph)
         ("C-c n i" . org-roam-node-insert)
         ("C-c n c" . org-roam-capture)
         ;; Dailies
         ("C-c n j" . org-roam-dailies-goto-today))
  :config
  ;; If you're using a vertical completion framework, you might want a more informative completion interface
  (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
  (org-roam-db-autosync-mode)
  ;; If using org-roam-protocol
  (require 'org-roam-protocol))

(add-hook 'org-roam-dailies-find-file-hook #'end-of-buffer)

(defvar jt/--pending-daily-frame nil)

(defun jt/--open-daily-delayed ()
  (when (and jt/--pending-daily-frame (frame-live-p jt/--pending-daily-frame))
    (with-selected-frame jt/--pending-daily-frame
      (setq jt/org-agenda-day-offset 0)
      (org-roam-dailies-goto-today)
      (split-window-below nil)
      (other-window 1)
      (org-agenda nil "g")
      (jt/agenda-collapse-empty-lines)
      (balance-windows)))
  (setq jt/--pending-daily-frame nil))

(defun jt/agenda-collapse-empty-lines ()
  "Remove empty time grid lines above the current time and collapse multiple blank lines."
  (let ((inhibit-read-only t)
        (now-pos nil))
    (goto-char (point-min))
    (when (re-search-forward " - - - - - - -" nil t)
      (setq now-pos (point)))
    (when now-pos
      (goto-char (point-min))
      (while (re-search-forward "^ +[0-9]+:00\\.\\{6\\} ----------------\n" now-pos t)
        (replace-match "")
        (setq now-pos (- now-pos (- (match-end 0) (match-beginning 0))))))
    (goto-char (point-min))
    (while (re-search-forward "\n\\{3,\\}" nil t)
      (replace-match "\n\n")))
  (goto-char (point-min)))

(defun jt/open-daily-on-new-frame (frame)
  "Open today's org-roam daily in new emacsclient frames."
  (when (daemonp)
    (setq jt/--pending-daily-frame frame)
    (run-at-time 0.1 nil #'jt/--open-daily-delayed)))

(add-hook 'after-make-frame-functions #'jt/open-daily-on-new-frame)
#+end_src
** Org-Inkscape
#+begin_src elisp
(defvar template-svg nil
  "Blank document for inkscape. You cannot create a file at the
  command line, so we put this template in and open it.")

(setq template-svg "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>
<!-- Created with Inkscape (http://www.inkscape.org/) -->

<svg
   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"
   xmlns:cc=\"http://creativecommons.org/ns#\"
   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"
   xmlns:svg=\"http://www.w3.org/2000/svg\"
   xmlns=\"http://www.w3.org/2000/svg\"
   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"
   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"
   width=\"800\"
   height=\"600\"
   viewBox=\"0 0 800 600\"
   id=\"svg2\"
   version=\"1.1\"
   inkscape:version=\"0.92.2 (5c3e80d, 2017-08-06)\"
   sodipodi:docname=\"some-sketch.svg\">
  <defs
     id=\"defs4\" />
  <sodipodi:namedview
     id=\"base\"
     pagecolor=\"#000000\"
     bordercolor=\"#666666\"
     borderopacity=\"1.0\"
     inkscape:pageopacity=\"1.0\"
     inkscape:pageshadow=\"2\"
     inkscape:zoom=\"1.0\"
     inkscape:cx=\"400\"
     inkscape:cy=\"300\"
     inkscape:document-units=\"px\"
     inkscape:current-layer=\"layer1\"
     showgrid=\"false\"
     inkscape:window-width=\"800\"
     inkscape:window-height=\"600\"
     inkscape:window-x=\"0\"
     inkscape:window-y=\"0\"
     inkscape:window-maximized=\"0\" />
  <metadata
     id=\"metadata7\">
    <rdf:RDF>
      <cc:Work
         rdf:about=\"\">
        <dc:format>image/svg+xml</dc:format>
        <dc:type
           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />
        <dc:title></dc:title>
      </cc:Work>
    </rdf:RDF>
  </metadata>
  <g
     inkscape:label=\"Layer 1\"
     inkscape:groupmode=\"layer\"
     id=\"layer1\" />
</svg>")


;; @jt-menu Tools | t i | Open in Inkscape
(defun inkscape-open (path)
  "Open the path in inkscape"
  (interactive "fSVG file: ")
  (unless (f-ext-p path "svg") (error "Must be an svg file."))
  (unless (file-exists-p path)
    (with-temp-file path
      (insert template-svg)))
  (shell-command (format "inkscape %s &" path)))

;; @jt-menu Org | o i | New Inkscape drawing
(defun jt/org-inkscape-new ()
  "Create new SVG in org file directory, embed it, and open in Inkscape.
When Inkscape closes, refresh inline images."
  (interactive)
  (unless (derived-mode-p 'org-mode)
    (error "Must be in org-mode"))
  (let ((filepath (buffer-file-name (buffer-base-buffer))))
    (unless filepath
      (let ((default-name (concat (file-name-sans-extension (buffer-name)) ".org")))
        (setq filepath (read-file-name "Save SVG in directory: " "~/org-roam/" nil nil default-name))
        (setq filepath (if (file-directory-p filepath)
                           filepath
                         (file-name-directory filepath)))))
    (let* ((dir (if (file-directory-p filepath) filepath (file-name-directory filepath)))
           (base (file-name-sans-extension (file-name-nondirectory filepath)))
           (timestamp (format-time-string "%Y%m%d-%H%M%S"))
           (filename (concat base "-" timestamp ".svg"))
           (svgpath (expand-file-name filename dir))
           (buf (current-buffer)))
      (when (file-exists-p svgpath)
        (error "File %s already exists" filename))
      (with-temp-file svgpath
        (insert template-svg))
      (insert (format "#+ATTR_ORG: :width 400\n[[file:%s]]" filename))
      (org-display-inline-images)
      (set-process-sentinel
       (start-process "inkscape" nil "inkscape" svgpath)
       (lambda (proc event)
         (when (string-match-p "finished\\|exited" event)
           (with-current-buffer buf
             (org-display-inline-images t t))))))))

(org-link-set-parameters
 "file"
 :follow (lambda (path)
       (let ((actions '(("find-file" . find-file)
                ("edit in inkscape" . inkscape-open))))
         (funcall (cdr (assoc (completing-read "Action: " actions) actions)) path))))
;; from https://emacs.stackexchange.com/questions/38345/open-an-external-sketch-drawing-application
#+end_src
** run prompt.py
#+begin_src elisp
;; @jt-menu Tools | t p | Run prompt.py
(defun run-prompt-with-marked-text ()
  "Run './prompt.py \"marked text\"' in the home directory using the marked text as input, asynchronously."
  (interactive)
  (if (use-region-p)
      (let* ((marked-text (buffer-substring-no-properties (region-beginning) (region-end)))
             (command (list "bash" "-c" (format "cd ~ && ./prompt.py %S" marked-text))))
        (apply #'start-process "script-process" "*script-output*" command)
        (message "Script is running in the background."))
    (message "No region selected! Please select the text to animate.")))

(global-set-key (kbd "C-x c p") #'run-prompt-with-marked-text)
#+end_src
** buffer modified timer
#+begin_src elisp
;; focus timer with a 10s repeated delay, giving a grace period to notice the time when returning to the buffer, but also recording the last afk+active period combined time (i.e. how long it's been since you last started a break)

(defvar buffer-last-modified-time nil
  "The last time the buffer was modified.")

(defun update-buffer-last-modified-time ()
  "Update the last modified time of the current buffer."
  (setq buffer-last-modified-time (current-time)))

(defun time-since-last-modified ()
  "Return the time since the buffer was last modified as a string."
  (if buffer-last-modified-time
      (let* ((seconds-since-modified (float-time (time-subtract (current-time) buffer-last-modified-time)))
             (minutes (floor (/ seconds-since-modified 60)))
             (seconds (mod seconds-since-modified 60)))
        (format "%d:%02d" minutes seconds))
    "0:00"))

(defvar timer-reset-timer nil
  "Timer used to reset the buffer modification timer.")

(defun reset-timer-after-grace-period ()
  "Reset the buffer modification timer after a grace period."
  (when timer-reset-timer
    (cancel-timer timer-reset-timer))
  (setq timer-reset-timer
        (run-with-timer 10 nil 'update-buffer-last-modified-time)))

(defun monitor-buffer-modifications ()
  "Monitor buffer modifications to update the last modified time."
  (reset-timer-after-grace-period))

(add-hook 'post-command-hook 'monitor-buffer-modifications)

(setq-default mode-line-buffer-identification
              '(:eval (format "%s %s"
                              (buffer-name)
                              (time-since-last-modified))))
#+end_src
** browser integration
#+begin_src elisp
(setq browse-url-generic-program
  (executable-find "chromium")
  browse-url-generic-args '("--new-tab")
  browse-url-browser-function 'browse-url-generic)
#+end_src
** lang stuff
#+begin_src elisp
;; set js-mode indent level
(add-hook 'js-mode-hook
  (lambda ()
    (setq js-indent-level 2)))

;; cider deps.edn config
(setq cider-clojure-cli-global-options "-R:cider-clj")

;; (modify-face whitespace-tab nil "#F92672")
(setq whitespace-style '(face tabs))
(whitespace-mode)
#+end_src
** Personal menu
Load at the end to avoid scanning partially-loaded org files.
#+begin_src elisp
;; @jt-menu Tools | t r | Reload config
(defun jt/reload-config ()
  "Tangle emacs.org and reload configuration."
  (interactive)
  (org-babel-tangle-file "~/.emacs.d/emacs.org")
  (load "~/.emacs.d/emacs.el")
  (jt/menu-rebuild)
  (message "Config tangled and reloaded"))

(require 'jt-menu)
#+end_src

** Google Calendar import
Import events from Google Calendar by copying text from the web agenda view.
*** Helper functions for parsing
#+begin_src elisp
(defun jt/gcal-month-to-number (month)
  "Convert MONTH abbreviation to two-digit number string."
  (pcase month
    ("Jan" "01") ("Feb" "02") ("Mar" "03") ("Apr" "04")
    ("May" "05") ("Jun" "06") ("Jul" "07") ("Aug" "08")
    ("Sep" "09") ("Sept" "09") ("Oct" "10") ("Nov" "11") ("Dec" "12")))

(defun jt/gcal-pad-day (day)
  "Pad DAY to two digits."
  (if (= (length day) 1)
      (concat "0" day)
    day))

(defun jt/gcal-clean-from-time (time)
  "Ensure TIME has minutes component."
  (if (< (length time) 3)
      (format "%s:00" time)
    time))

(defun jt/gcal-add-am-pm (from to)
  "Add am/pm suffix from TO time to FROM time if missing."
  (if (string-match-p ".*[ap]m" from)
      from
    (if (string-match "^.*\\([ap]m\\)$" to)
        (format "%s%s" from (match-string 1 to))
      from)))

(defun jt/gcal-format-time (time-string)
  "Parse TIME-STRING like '10am – 11am' into org time range."
  (when (string-match "\\(.*\\) – \\(.*\\)" time-string)
    (let* ((to-time (match-string 2 time-string))
           (from-time (jt/gcal-add-am-pm
                       (jt/gcal-clean-from-time (match-string 1 time-string))
                       to-time)))
      (format "%s-%s" from-time to-time))))

(defun jt/gcal-time-to-minutes (time-str)
  "Convert time string like '10am' or '6:30pm' to minutes since midnight."
  (let ((hour 0) (min 0) (pm nil))
    (when (string-match "\\([0-9]+\\)\\(?::\\([0-9]+\\)\\)?\\([ap]m\\)" time-str)
      (setq hour (string-to-number (match-string 1 time-str)))
      (setq min (if (match-string 2 time-str) (string-to-number (match-string 2 time-str)) 0))
      (setq pm (string= "pm" (match-string 3 time-str)))
      (when (and pm (< hour 12)) (setq hour (+ hour 12)))
      (when (and (not pm) (= hour 12)) (setq hour 0)))
    (+ (* hour 60) min)))

(defun jt/gcal-duration-hours (time-string)
  "Return duration in hours for TIME-STRING like '10am – 6:30pm'."
  (when (and time-string (string-match "\\(.*\\) – \\(.*\\)" time-string))
    (let ((from-str (match-string 1 time-string))
          (to-str (match-string 2 time-string)))
      (let ((from (jt/gcal-time-to-minutes from-str))
            (to (jt/gcal-time-to-minutes to-str)))
        (/ (- to from) 60.0)))))
#+end_src
*** Parser function
#+begin_src elisp
(defun jt/gcal-to-org (org-buffer-name)
  "Parse Google Calendar text in current buffer, output org to ORG-BUFFER-NAME."
  (goto-char (point-min))
  (let ((org-buffer (get-buffer-create org-buffer-name))
        (current-day nil)
        (current-year (nth 2 (calendar-current-date)))
        (current-month nil)
        (current-time nil))
    (with-current-buffer org-buffer
      (org-mode)
      (erase-buffer)
      (insert "* Work Calendar\n"))
    (while (< (line-number-at-pos) (count-lines (point-min) (point-max)))
      (let ((current-line (buffer-substring-no-properties
                           (line-beginning-position)
                           (line-end-position))))
        (cond
         ((string-match "^[0-9]\\{1,2\\}$" current-line)
          (setq current-day (jt/gcal-pad-day (match-string 0 current-line))))
         ((string-match "^\\([A-Za-z]\\{3,4\\}\\),.\\{3,4\\}$" current-line)
          (setq current-month (match-string 1 current-line)))
         ((string-match "^\\(.*[ap]m\\)$" current-line)
          (setq current-time (match-string 1 current-line)))
         (t
          (let ((event-name (string-trim current-line)))
            (when (and current-time current-month current-day (not (string-empty-p event-name)))
              (let ((duration (jt/gcal-duration-hours current-time)))
                (unless (and (string-match-p "XTDB Chat" event-name)
                             duration
                             (> duration 6))
                  (with-current-buffer org-buffer
                    (insert (format "** %s <%s-%s-%s %s>\n"
                                    event-name
                                    current-year
                                    (jt/gcal-month-to-number current-month)
                                    current-day
                                    (jt/gcal-format-time current-time))))))
              (setq current-time nil))))))
      (forward-line))))
#+end_src
*** Interactive import command
#+begin_src elisp
(defvar jt/gcal-output-file "~/org/work-cal.org"
  "File to write imported Google Calendar events.")

;; @jt-menu Org | o g | Import Google Calendar
(defun jt/gcal-import ()
  "Import events from Google Calendar.
Opens a buffer to paste calendar text, then writes to work-cal.org."
  (interactive)
  (let ((raw-buffer (get-buffer-create "*jt/gcal-import-raw*")))
    (switch-to-buffer raw-buffer)
    (erase-buffer)
    (browse-url "https://calendar.google.com/calendar/u/0/r/agenda")
    (insert "Paste Google Calendar agenda text here, then press C-c C-c\n")
    (insert "------------------------------------------------------\n\n")
    (local-set-key
     (kbd "C-c C-c")
     (lambda ()
       (interactive)
       (let ((org-buffer (get-buffer-create "*jt/gcal-import-org*")))
         (save-excursion
           (goto-char (point-min))
           (forward-line 3)
           (delete-region (point-min) (point)))
         (jt/gcal-to-org org-buffer)
         (with-current-buffer org-buffer
           (write-file (expand-file-name jt/gcal-output-file))
           (message "Wrote %d lines to %s"
                    (count-lines (point-min) (point-max))
                    jt/gcal-output-file))
         (when-let ((existing (find-buffer-visiting (expand-file-name jt/gcal-output-file))))
           (with-current-buffer existing
             (revert-buffer t t)))
         (kill-buffer "*jt/gcal-import-raw*"))))))
#+end_src
